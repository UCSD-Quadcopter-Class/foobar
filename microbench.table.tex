%&How does it ensure that only persistent data types reside in persistent memory?&How does it prevent (or ensure the validity of) pointers from one NV region/pool to another region/pool?&How does it prevent pointers from an NV region into DRAM?&How does it ensure the safety of pointers from DRAM to NV?  For example, if an NV object's reference count goes to zero and it is deallocated or the persistent region is unmapped, how do you prevent dereferences to the resulting invalid pointers in volatile memory?&How does it prevent unsynchronized access to shared persistent data?&How does it prevent unlogged writes to persistent data?&How does it prevent modifications to persistent data outside of transactions?&How does it prevent persistent memory leaks?
Operation&\multicolumn{2}{c||}{Optane DC}&\multicolumn{2}{c|}{DRAM}\\\cline{2-5}
&Mean (ns)&STD (ns)&Mean (ns)&STD (ns)\\\hline\hline
Alloc(8)&665&738&229&181\\\hline
Alloc(256)&963&21731&339&790\\\hline
Alloc(4K)&4124&130499&1959&2571\\\hline
Dealloc(8)&771&948&246&149\\\hline
Dealloc(256)&695&750&236&134\\\hline
Dealloc(4K)&680&601&234&117\\\hline
% TxNop&1984&724&816&152\\\hline
TxNop&203&119&192&73\\\hline
DataLog(8)&898&5442&291&385\\\hline
DataLog(2K)&853&7573&329&665\\\hline
DataLog(32K)&5947&101974&1974&1978\\\hline
DropLog(8)&88&483&60&349\\\hline
DropLog(32K)&103&5293&59&353\\\hline
Pbox::clone&1399&822&419&152\\\hline
Prc::clone&19&10&19&9\\\hline
Prc::downgrade&20&10&20&8\\\hline
Prc::Weak:upgrade&20&11&20&11\\\hline
Parc::clone&29&7&29&19\\\hline
Parc::demote&74&167&75&160\\\hline
Parc::downgrade&32&9&32&12\\\hline
Parc::VWeak::promote&33&11&33&6\\\hline
Parc::Weak::upgrade&32&11&32&14\\\hline
Deref&18&6.9&18&7.5\\\hline
DerefMut&20&7.8&20&6.8\\\hline