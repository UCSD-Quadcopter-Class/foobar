@inproceedings{corfu,
 author = {Balakrishnan, Mahesh and Malkhi, Dahlia and Prabhakaran, Vijayan and Wobber, Ted and Wei, Michael and Davis, John D.},
 title = {CORFU: a shared log design for flash clusters},
 booktitle = {Proceedings of the 9th USENIX conference on Networked Systems Design and Implementation},
 series = {NSDI'12},
 year = {2012},
 location = {San Jose, CA},
 pages = {1--1},
 numpages = {1},
 url = {http://dl.acm.org/citation.cfm?id=2228298.2228300},
 acmid = {2228300},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
} 
@misc{personalbillbridge,
  author = "Bridge, Bill",
  year = "2020",
  howpublished = "personal communication"
}



@article{rudoff2017persistent,
  title={Persistent memory programming},
  author={Rudoff, Andy},
  journal={Login: The Usenix Magazine},
  volume={42},
  pages={34--40},
  year={2017}
}

@misc{mostloved,
key={stack overflow},
url={https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted}
}

@misc{rust,
    title = {Rust Programming Language},
    note={\url{https://www.rust-lang.org/}}
}

@inproceedings{kolli2016high,
  title={High-performance transactions for persistent memories},
  author={Kolli, Aasheesh and Pelley, Steven and Saidi, Ali and Chen, Peter M and Wenisch, Thomas F},
  booktitle={Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages={399--411},
  year={2016}
}

@article{rewind,
  title={Rewind: Recovery write-ahead system for in-memory non-volatile data-structures},
  author={Chatzistergiou, Andreas and Cintra, Marcelo and Viglas, Stratis D},
  journal={Proceedings of the VLDB Endowment},
  volume={8},
  number={5},
  pages={497--508},
  year={2015},
  publisher={VLDB Endowment}
}

@inproceedings{ogleari2018steal,
  title={Steal but no force: Efficient hardware undo+ redo logging for persistent memory systems},
  author={Ogleari, Matheus Almeida and Miller, Ethan L and Zhao, Jishen},
  booktitle={2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)},
  pages={336--349},
  year={2018},
  organization={IEEE}
}

@inproceedings{nvthreads,
  title={NVthreads: Practical persistence for multi-threaded applications},
  author={Hsu, Terry Ching-Hsiang and Br{\"u}gner, Helge and Roy, Indrajit and Keeton, Kimberly and Eugster, Patrick},
  booktitle={Proceedings of the Twelfth European Conference on Computer Systems},
  pages={468--482},
  year={2017}
}

@inproceedings{log-nvmm,
  title={Log-structured non-volatile main memory},
  author={Hu, Qingda and Ren, Jinglei and Badam, Anirudh and Shu, Jiwu and Moscibroda, Thomas},
  booktitle={2017 $\{$USENIX$\}$ Annual Technical Conference ($\{$USENIX$\}$$\{$ATC$\}$ 17)},
  pages={703--717},
  year={2017}
}

@inproceedings{pmtest,
  title={PMTest: A fast and flexible testing framework for persistent memory programs},
  author={Liu, Sihang and Wei, Yizhou and Zhao, Jishen and Kolli, Aasheesh and Khan, Samira},
  booktitle={Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages={411--425},
  year={2019}
}

@online{golang,
  note={\url{https://golang.org/}},
  title = {The {Go} Programming Language},
}

@online{pony,
  note={\url{https://www.ponylang.io/}},
  title = {Pony programming language},
}

@online{rustbook,
  note={\url{https://doc.rust-lang.org/book/}},
  title = {The Rust Programming Language},
  author = {Klabnik, Steve and Nichols, Carol},
}

@online{intel-pmemcheck,
  note={\url{https://pmem.io/2015/07/17/pmemcheck-basic.html}},
  title = {An introduction to pmemcheck},
  year = {2015},
}

@online{intel-inspector,
  note={\url{https://software.intel.com/}},
  title = {How to detect persistent memory programming errors using Intel Inspector - Persistence Inspector},
  author = {Oleary, Kevin},
  year = {2018},
}

@inproceedings{ido,
  title={iDO: Compiler-directed failure atomicity for nonvolatile memory},
  author={Liu, Qingrui and Izraelevitz, Joseph and Lee, Se Kwon and Scott, Michael L and Noh, Sam H and Jung, Changhee},
  booktitle={2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)},
  pages={258--270},
  year={2018},
  organization={IEEE}
}

@article{usnap,
  author = {Kim, J. Hyun and Moon, Young Je and Song, Hyunsub and Park, Jay H. and Noh, Sam H.},
  title = {On Providing OS Support to Allow Transparent Use of Traditional Programming Models for Persistent Memory},
  year = {2020},
  issue_date = {July 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {16},
  number = {3},
  issn = {1550-4832},
  url = {https://doi.org/10.1145/3388637},
  doi = {10.1145/3388637},
  journal = {J. Emerg. Technol. Comput. Syst.},
  month = jun,
  articleno = {33},
  numpages = {24},
  keywords = {fault tolerance, fine-grained checkpointing, Persistent memory, persistency model}
}

@article{cohen2018object,
  title={Object-oriented recovery for non-volatile memory},
  author={Cohen, Nachshon and Aksun, David T and Larus, James R},
  journal={Proceedings of the ACM on Programming Languages},
  volume={2},
  number={OOPSLA},
  pages={1--22},
  year={2018},
  publisher={ACM New York, NY, USA}
}

@inproceedings{autopersist,
  author = {Shull, Thomas and Huang, Jian and Torrellas, Josep},
  title = {AutoPersist: An Easy-to-Use Java NVM Framework Based on Reachability},
  year = {2019},
  isbn = {9781450367127},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3314221.3314608},
  doi = {10.1145/3314221.3314608},
  abstract = {Byte-addressable, non-volatile memory (NVM) is emerging as a revolutionary memory technology that provides persistency, near-DRAM performance, and scalable capacity. To facilitate its use, many NVM programming models have been proposed. However, most models require programmers to explicitly specify the data structures or objects that should reside in NVM. Such requirement increases the burden on programmers, complicates software development, and introduces opportunities for correctness and performance bugs.  We believe that requiring programmers to identify the data structures that should reside in NVM is untenable. Instead, programmers should only be required to identify durable roots - the entry points to the persistent data structures at recovery time. The NVM programming framework should then automatically ensure that all the data structures reachable from these roots are in NVM, and stores to these data structures are persistently completed in an intuitive order.  To this end, we present a new NVM programming framework, named AutoPersist, that only requires programmers to identify durable roots. AutoPersist then persists all the data structures that can be reached from the durable roots in an automated and transparent manner. We implement AutoPersist as a thread-safe extension to the Java language and perform experiments with a variety of applications running on Intel Optane DC persistent memory. We demonstrate that AutoPersist requires minimal code modifications, and significantly outperforms expert-marked Java NVM applications.},
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages = {316–332},
  numpages = {17},
  keywords = {JIT Compilation, Non-Volatile Memory, Java},
  location = {Phoenix, AZ, USA},
  series = {PLDI 2019}
}

@inproceedings{janus,
  author = {Liu, Sihang and Seemakhupt, Korakit and Pekhimenko, Gennady and Kolli, Aasheesh and Khan, Samira},
  title = {Janus: Optimizing Memory and Storage Support for Non-Volatile Memory Systems},
  year = {2019},
  isbn = {9781450366694},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3307650.3322206},
  doi = {10.1145/3307650.3322206},
  abstract = {Non-volatile memory (NVM) technologies can manipulate persistent data directly in memory. Ensuring crash consistency of persistent data enforces that data updates reach all the way to NVM, which puts these write requests on the critical path. Recent literature sought to reduce this performance impact. However, prior works have not fully accounted for all the backend memory operations (BMOs) performed at the memory controller that are necessary to maintain persistent data in NVM. These BMOs include support for encryption, integrity protection, compression, deduplication, etc., necessary to provide security, endurance, and lifetime guarantees. These BMOs significantly increase the NVM write latency and exacerbate the performance degradation caused by the critical write requests. The goal of this work is to minimize the BMO overhead of write requests in an NVM system.The central challenge is to figure out how to optimize these seemingly dependent and monolithic BMOs. Our key insight is to decompose each BMO into a series of sub-operations and then reduce their overall latency through two mechanisms: (i) parallelize sub-operations across BMOs and (ii) pre-execute sub-operations off the critical path as soon as their inputs are ready. We expose a generic software interface that can be used to issue pre-execution requests compatible with common crash-consistency programming models and various BMOs. Based on these ideas, we propose Janus1 - a hardware-software co-design that parallelizes and pre-executes BMOs in an NVM system. We evaluate Janus in an NVM system that integrates encryption, integrity verification, and deduplication and issues pre-execution requests through the proposed software interface, either manually or using an automated compiler pass. Compared to a system that performs these operations serially, Janus achieves 2.35\texttimes{} and 2.00\texttimes{} speedup using manual and automated instrumentation, respectively.},
  booktitle = {Proceedings of the 46th International Symposium on Computer Architecture},
  pages = {143–156},
  numpages = {14},
  keywords = {pre-execution, parallelization, non-volatile memory, crash consistency},
  location = {Phoenix, Arizona},
  series = {ISCA '19}
}

@article{libpm,
  author = {Marmol, Leonardo and Chowdhury, Mohammad and Rangaswami, Raju},
  title = {{PM: Simplifying Application Usage of Persistent Memory}},
  year = {2018},
  issue_date = {December 2018},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {14},
  number = {4},
  issn = {1553-3077},
  url = {https://doi.org/10.1145/3278141},
  doi = {10.1145/3278141},
  abstract = {Persistent Memory devices present properties that are uniquely different from prior technologies for which applications have been built. Unfortunately, the conventional approach to building applications fail to either efficiently utilize these new devices or provide programmers a seamless development experience. We have built LibPM, a Persistent Memory Library that implements an easy-to-use container abstraction for consuming PM. LibPM’s containers are data hosting units that can store arbitrarily complex data types while preserving their integrity and consistency. Consequently, LibPM’s containers provide a generic interface to applications, allowing applications to store and manipulate arbitrarily structured data with strong durability and consistency properties, all without having to navigate all the myriad pitfalls of programming PM directly. By providing a simple and high-performing transactional update mechanism, LibPM allows applications to manipulate persistent data at the speed of memory. The container abstraction and automatic persistent data discovery mechanisms within LibPM also simplify porting legacy applications to PM. From a performance perspective, LibPM closely matches and often exceeds the performance of state-of-the-art application libraries for PM. For instance, LibPM ’s performance is 195\texttimes{} better for write intensive workloads and 2.6\texttimes{} better for read intensive workloads when compared with the state-of-the-art Pmem.IO persistent memory library.},
  journal = {ACM Trans. Storage},
  month = dec,
  articleno = {34},
  numpages = {18},
  keywords = {Persistent memory, next-generation applications, application persistence}
}

@inproceedings{lazypersist,
  title={Lazy persistency: A high-performing and write-efficient software persistency technique},
  author={Alshboul, Mohammad and Tuck, James and Solihin, Yan},
  booktitle={2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)},
  pages={439--451},
  year={2018},
  organization={IEEE}
}

@inproceedings {pisces,
  author = {Jinyu Gu and Qianqian Yu and Xiayang Wang and Zhaoguo Wang and Binyu Zang and Haibing Guan and Haibo Chen},
  title = {Pisces: A Scalable and Efficient Persistent Transactional Memory},
  booktitle = {2019 {USENIX} Annual Technical Conference ({USENIX} {ATC} 19)},
  year = {2019},
  isbn = {978-1-939133-03-8},
  address = {Renton, WA},
  pages = {913--928},
  url = {https://www.usenix.org/conference/atc19/presentation/gu},
  publisher = {{USENIX} Association},
  month = jul,
}

@inproceedings{jeong2018efficient,
  title={Efficient hardware-assisted logging with asynchronous and direct-update for persistent memory},
  author={Jeong, Jungi and Park, Chang Hyun and Huh, Jaehyuk and Maeng, Seungryoul},
  booktitle={2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)},
  pages={520--532},
  year={2018},
  organization={IEEE}
}

@inproceedings{xu2020hardware,
  title={Hardware-Based Domain Virtualization for Intra-Process Isolation of Persistent Memory Objects},
  author={Xu, Yuanchao and Ye, ChenCheng and Solihin, Yan and Shen, Xipeng},
  booktitle={2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)},
  pages={680--692},
  year={2020},
  organization={IEEE}
}

@inproceedings{oukid2016testing,
  title={On testing persistent-memory-based software},
  author={Oukid, Ismail and Booss, Daniel and Lespinasse, Adrien and Lehner, Wolfgang},
  booktitle={Proceedings of the 12th International Workshop on Data Management on New Hardware},
  pages={1--7},
  year={2016}
}

@inproceedings{xfdetector ,
  title={Cross-Failure Bug Detection in Persistent Memory Programs},
  author={Liu, Sihang and Seemakhupt, Korakit and Wei, Yizhou and Wenisch, Thomas and Kolli, Aasheesh and Khan, Samira},
  booktitle={Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages={1187--1202},
  year={2020}
}

@inproceedings{gopmem,
  title={go-pmem: Native Support for Programming Persistent Memory in Go},
  author={George, Jerrin Shaji and Verma, Mohit and Venkatasubramanian, Rajesh and Subrahmanyam, Pratap},
  booktitle={2020 {USENIX} Annual Technical Conference ({USENIX ATC} 20)},
  pages={859--872},
  year={2020}
}

@article{convoider,
  title={Convoider: A Concurrency Bug Avoider Based on Transparent Software Transactional Memory},
  author={Yu, Zhen and Zuo, Yu and Zhao, Yong},
  journal={International Journal of Parallel Programming},
  volume={48},
  number={1},
  pages={32--60},
  year={2020},
  publisher={Springer}
}

@inproceedings{grace,
  title={Grace: Safe multithreaded programming for C/C++},
  author={Berger, Emery D and Yang, Ting and Liu, Tongping and Novark, Gene},
  booktitle={Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications},
  pages={81--96},
  year={2009}
}

@inproceedings{tm2c,
  title={TM2C: a software transactional memory for many-cores},
  author={Gramoli, Vincent and Guerraoui, Rachid and Trigonakis, Vasileios},
  booktitle={Proceedings of the 7th ACM european conference on Computer Systems},
  pages={351--364},
  year={2012}
}

@article{stmlock,
  title={Software engineering with transactional memory versus locks in practice},
  author={Pankratius, Victor and Adl-Tabatabai, Ali-Reza},
  journal={Theory of Computing Systems},
  volume={55},
  number={3},
  pages={555--590},
  year={2014},
  publisher={Springer}
}

@article{atkinson1995orthogonally,
  title={Orthogonally persistent object systems},
  author={Atkinson, Malcolm and Morrison, Ronald},
  journal={The VLDB Journal},
  volume={4},
  number={3},
  pages={319--401},
  year={1995},
  publisher={Springer}
}

@article{buddy,
  author = {Knowlton, Kenneth C.},
  title = {A Fast Storage Allocator},
  year = {1965},
  issue_date = {Oct. 1965},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {10},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/365628.365655},
  doi = {10.1145/365628.365655},
  journal = {Commun. ACM},
  month = oct,
  pages = {623–624},
  numpages = {2}
}