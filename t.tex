\subsection{Example}

\reflst{lst:example} implements \cfunc{append} for a persistent linked list in \this{}.  A \csym{Node} contains an integer and a link to the next \csym{Node}.  The link is of type \csym{PRefCell<Option<Pbox<Node,P>{>,P>}}, which might seem daunting, but this is typical for a Rust pointer declaration.  To break it down: \csym{PBox<Node, P>} is pointer to a \csym{Node} in pool \csym{P}.  \csym{Option<>} is the Rust idiom for a pointer that can be null.  It can have one of two values: \csym{None} (i.e., null) or a \csym{Some(Pbox)} (which cannot be null).  Wrapping the \csym{Option} in \csym{PRefCell} allows for modification via interior mutability.

\cfunc{Node::append} recursively finds the end of the list and adds a \csym{Node}.  \refl{ln:borrow} uses \cfunc{PRefCell::borrow\_mut} to get an mutable reference, \csym{t}, to the \csym{Option} object the \csym{PRefCell} contains.   \refl{ln:match} uses Rust's pattern matching \csym{match} construct to safely handle all possible values of \csym{t}: \csym{None} or \csym{Some}.  In the \csym{Some} (i.e., non-null) case, it binds the content of the \csym{Option} (which has type \csym{Node}) to \csym{succ}, and recursively calls \cfunc{Node::append}.

If the \csym{Option} is \csym{None}, the code has reached the end of the list.  Line~\ref{len:new} creates a \csym{PBox} to allocates a new \csym{Node} with value \csym{k} and a \csym{next} pointer equal to \csym{None}.  It wraps the \csym{PBox} in a non-null value of type \csym{Option}, and assigns it to the mutable reference.


Function \cfunc{go} opens ``list.pool'' and binds it to pool type \csym{P}.  The root pointer will hold a \csym{Node} struct.  \refl{ln:tx} starts a transaction, which provides a journal object, which \refl{ln:call} passes to \cfunc{append}.

Several aspects of the code are notable.  First, \csym{head} and \csym{n} are both immutable, so changes are not possible until \cfunc{borrow\_mut} uses interior mutability to return a mutable reference object.  Second, we must pass \csym{j} into \cfunc{append} to ensure it executes in a transaction thereby allowing the call to \cfunc{borrow\_mut}  and the memory allocation (\refl{ln:new}).  Third, although we create call \cfunc{borrow\_mut} for every link in the list, \this{} only logs the last one, since logging only happens when \csym{*t} dereferences the reference object.  Forth, as written, \csym{Node} and \csym{append} only work on pool type \csym{P}.  A more complete implementation would be make \csym{P} a generic type parameter, so they could work on any pool type.


\begin{lstfloat}
\begin{lstlisting}
struct Node { val: i32, next: PRefCell<Option<Pbox<Node,P>##>,P> }
fn append(n: &Node, v:i32, j:&Journal<P>) {
  let mut t = n.next.borrow_mut(j);#\label{ln:borrow}#
  match &*t {#\label{ln:match}#
    Some(succ) => {
      append(succ, v, j);
    }
    None => {
      *t = Some(Pbox::new(#\label{ln:new}#
        Node {
          val: v,
          next: PRefCell::new(None, j)
        }, j));
    }
  }
}
fn go(v: i32) {
  let head = P::open::<Node>("list.pool",0).unwrap();
  P::transaction(|j| {
    append(&head, v, j);
  });
}
\end{lstlisting}
\label{lst:example}
\caption{A \this{} implementation of linked list append.  Some error management code has been elided for clarity.}
\end{lstfloat}
